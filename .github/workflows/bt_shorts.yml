name: BT Shorts

on:
  workflow_dispatch:
    inputs:
      topic:
        description: "Topic for today's short"
        required: true
        type: string
  push:
    paths:
      - "bt/*.mp3"
      - "bt/*.wav"
      - "bt/*.txt"
  schedule:
    - cron: "0 21 * * *"   # 19:00 UTC = 00:30 IST
    
jobs:
  build:
    runs-on: ubuntu-latest
    env:
      YT_DIR: bt
    permissions:
      contents: read

    steps:
      - name: Checkout animated
        uses: actions/checkout@v4

      - name: Detect input mode
        shell: bash
        run: |
          set -euo pipefail
      
          MODE="dispatch"
          if [[ "${{ github.event_name }}" == "push" ]]; then
            if ls -1 ${{ env.YT_DIR }}/*.txt >/dev/null 2>&1; then
              MODE="yt_txt"
            elif ls -1 ${{ env.YT_DIR }}/*.mp3 ${{ env.YT_DIR }}/*.wav ${{ env.YT_DIR }}/*.m4a ${{ env.YT_DIR }}/*.mpeg >/dev/null 2>&1; then
              MODE="yt_audio"
            else
              MODE="push_unknown"
            fi
          fi
      
          echo "INPUT_MODE=$MODE" >> "$GITHUB_ENV"
          echo "INPUT_MODE=$MODE"

      - name: Set topic (dispatch vs schedule)
        shell: bash
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo 'TOPIC=Most trending topic of today of your choice' >> "$GITHUB_ENV"
          else
            echo 'TOPIC=${{ inputs.topic }}' >> "$GITHUB_ENV"
          fi
                

      - name: Checkout ytci (private)
        uses: actions/checkout@v4
        with:
          repository: prkpushp/ytci
          token: ${{ secrets.CROSS_REPO_PAT }}
          path: ytci
          fetch-depth: 1

      - name: Validate channel config JSON
        run: |
          set -euo pipefail
          jq -e . ytci/${{ env.YT_DIR }}/input.json >/dev/null
          echo "âœ… ytci/${{ env.YT_DIR }}/input.json is valid JSON"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: ytci/scripts/requirements.txt

      - name: Auth to Google Cloud (service account JSON)
        uses: google-github-actions/auth@v3
        with:
          credentials_json: ${{ secrets.GOOGLE_CLOUD_CREDENTIALS }}
          create_credentials_file: true
          export_environment_variables: true

      - name: Verify Google Cloud authentication
        run: |
          set -euo pipefail
          gcloud auth list
          export PROJECT_ID="$(jq -r .project_id < "${{ env.GOOGLE_APPLICATION_CREDENTIALS }}")"
          echo "PROJECT_ID=$PROJECT_ID" >> $GITHUB_ENV

      - name: System dependencies (ffmpeg + fonts)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg fonts-dejavu-core jq

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r ytci/scripts/requirements.txt

      - name: Prepare workspace
        run: |
          echo "Preparing workspace: $YT_DIR"
          mkdir -p ${{ env.YT_DIR }}/input ${{ env.YT_DIR }}/output ${{ env.YT_DIR }}/tmp ${{ env.YT_DIR }}/voiceover ${{ env.YT_DIR }}/generated_frames

      - name: Generate JSON (Vertex Gemini)
        if: env.INPUT_MODE != 'yt_txt' && env.INPUT_MODE != 'yt_audio'
        env:
          LOCATION: us-central1
          TOPIC: ${{ env.TOPIC }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
          CHANNEL_CONFIG: ytci/${{ env.YT_DIR }}/input.json
        run: |
          set -euo pipefail
          TEMPLATE="$(jq -r '.gemini.prompt_template' "$CHANNEL_CONFIG")"
          if [[ -z "${TEMPLATE//[[:space:]]/}" || "$TEMPLATE" == "null" ]]; then
            echo "Missing .gemini.prompt_template in $CHANNEL_CONFIG"
            exit 1
          fi
          PROMPT="${TEMPLATE//\{\{TOPIC\}\}/$TOPIC}"
          jq -n --arg text "$PROMPT" '{
            contents: [{ role: "user", parts: [{ text: $text }] }],
            generationConfig: { temperature: 0.7, maxOutputTokens: 512 }
          }' > ${{ env.YT_DIR }}/tmp/gemini_req.json

          API="https://${LOCATION}-aiplatform.googleapis.com/v1/projects/${PROJECT_ID}/locations/${LOCATION}/publishers/google/models/gemini-2.0-flash-001:generateContent"

          curl -sS -X POST \
            -H "Authorization: Bearer $(gcloud auth print-access-token)" \
            -H "Content-Type: application/json" \
            "$API" \
            -d @${{ env.YT_DIR }}/tmp/gemini_req.json \
            > ${{ env.YT_DIR }}/tmp/gemini_resp.json

          if jq -e '.error' >/dev/null 2>&1 < ${{ env.YT_DIR }}/tmp/gemini_resp.json; then
            jq -r '.error | {code, message, status}' ${{ env.YT_DIR }}/tmp/gemini_resp.json
            cat ${{ env.YT_DIR }}/tmp/gemini_resp.json
            exit 1
          fi

          RAW="$(jq -r '[.candidates[0].content.parts[].text] | join("")' ${{ env.YT_DIR }}/tmp/gemini_resp.json)"
          echo "$RAW" > ${{ env.YT_DIR }}/voiceover/yt_raw.txt

          python - <<'PY'
          import json, re, pathlib
          p = pathlib.Path("${{ env.YT_DIR }}/voiceover/yt_raw.txt").read_text(encoding="utf-8").strip()
          m = re.search(r"\{.*\}", p, flags=re.S)
          if not m:
              raise SystemExit("No JSON object found in model output")
          data = json.loads(m.group(0))
          pathlib.Path("${{ env.YT_DIR }}/voiceover/yt.json").write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
          print("Wrote ${{ env.YT_DIR }}/voiceover/yt.json")
          PY

      - name: Script_content -> WAV (TTS via ytci tts.sh + input.json)
        if: env.INPUT_MODE != 'yt_audio'
        shell: bash
        env:
          PROJECT_ID: ${{ env.PROJECT_ID }}
          CHANNEL_CONFIG: ytci/${{ env.YT_DIR }}/input.json
        run: |
          set -euo pipefail
          mkdir -p ${{ env.YT_DIR }}/input
          chmod +x ytci/scripts/tts.sh
      
          if [[ "${INPUT_MODE}" == "yt_txt" ]]; then
            TXT_FILE="$(ls -1 ${{ env.YT_DIR }}/*.txt | head -n 1)"
            echo "Using yt txt: $TXT_FILE"
            TEXT="$(cat "$TXT_FILE")"
          else
            TEXT="$(jq -r '.script_content' ${{ env.YT_DIR }}/voiceover/yt.json)"
          fi
      
          ytci/scripts/tts.sh "$TEXT" ${{ env.YT_DIR }}/input/voiceover.wav


      - name: Pick audio file
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ${{ env.YT_DIR }}/input
      
          if [[ "${INPUT_MODE}" == "yt_audio" ]]; then
            AUDIO_FILE="$(find yt -maxdepth 1 -type f \( -iname "*.mp3" -o -iname "*.wav" -o -iname "*.mpeg" -o -iname "*.m4a" \) | sort | head -n 1)"
          else
            AUDIO_FILE="$(find ${{ env.YT_DIR }}/input -maxdepth 1 -type f \( -iname "*.mp3" -o -iname "*.wav" -o -iname "*.mpeg" -o -iname "*.m4a" \) | sort | head -n 1)"
          fi
      
          test -n "${AUDIO_FILE:-}"
          echo "MP3_FILE=$AUDIO_FILE" >> "$GITHUB_ENV"
          echo "Using audio: $AUDIO_FILE"


      - name: Speed up audio (ffmpeg, keep extension)
        shell: bash
        env:
          AUDIO_SPEED: "1.1"   # change this when needed
        run: |
          set -euo pipefail
      
          SPEED="${AUDIO_SPEED:-1.25}"
          FILTER="atempo=${SPEED}"
      
          IN_FILE="${MP3_FILE}"
          mkdir -p ${{ env.YT_DIR }}/tmp
      
          EXT="${IN_FILE##*.}"
          EXT_LC="$(echo "$EXT" | tr '[:upper:]' '[:lower:]')"
          BASE="$(basename "$IN_FILE")"
          STEM="${BASE%.*}"
      
          OUT_FILE="${{ env.YT_DIR }}/tmp/${STEM}_${SPEED}x.${EXT_LC}"
      
          case "$EXT_LC" in
            wav)
              ffmpeg -y -i "$IN_FILE" -filter:a "$FILTER" -vn -c:a pcm_s16le "$OUT_FILE"
              ;;
            mp3)
              ffmpeg -y -i "$IN_FILE" -filter:a "$FILTER" -vn -c:a libmp3lame -q:a 2 "$OUT_FILE"
              ;;
            m4a|mp4)
              ffmpeg -y -i "$IN_FILE" -filter:a "$FILTER" -vn -c:a aac -b:a 192k "$OUT_FILE"
              ;;
            aac)
              ffmpeg -y -i "$IN_FILE" -filter:a "$FILTER" -vn -c:a aac -b:a 192k -f adts "$OUT_FILE"
              ;;
            mpeg|mpg)
              ffmpeg -y -i "$IN_FILE" -filter:a "$FILTER" -vn -c:a mp2 -b:a 192k "$OUT_FILE"
              ;;
            *)
              echo "Unknown extension .$EXT_LC; defaulting to mp3 output."
              OUT_FILE="${{ env.YT_DIR }}/tmp/${STEM}_${SPEED}x.mp3"
              ffmpeg -y -i "$IN_FILE" -filter:a "$FILTER" -vn -c:a libmp3lame -q:a 2 "$OUT_FILE"
              ;;
          esac
      
          echo "MP3_FILE=$OUT_FILE" >> "$GITHUB_ENV"
          ls -lh "$OUT_FILE"
      


      - name: Run generator (ytci code, workspace)
        env:
          LOCATION: us-central1
          CHANNEL_NAME: Borderline Theory
          CHANNEL_CONFIG: ytci/${{ env.YT_DIR }}/input.json
          WORK_DIR: ${{ vars.YT_DIR }}
          FRAMES_DIR: ${{ env.YT_DIR }}/generated_frames
          OUTPUT_DIR: ${{ env.YT_DIR }}/output
          YT_JSON_PATH: ${{ env.YT_DIR }}/voiceover/yt.json
        run: |
          python ytci/scripts/generate_shorts.py

      - name: Upload outputs
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.YT_DIR }}-output-run${{ github.run_id }}
          if-no-files-found: error
          path: |
            ${{ env.YT_DIR }}/output/*.mp4
            ${{ env.YT_DIR }}/output/*.json
            ${{ env.YT_DIR }}/input/*
            ${{ env.YT_DIR }}/voiceover/*
            
      - name: Write run ID to repo
        env:
          GH_TOKEN: ${{ secrets.CROSS_REPO_PAT }}
          RUN_ID: ${{ github.run_id }}
          CHANNEL_CONFIG: ytci/${{ env.YT_DIR }}/input.json
        run: |
          set -euo pipefail
          TARGET_REPO="$(jq -r '.run_id_writer.repo' "$CHANNEL_CONFIG")"
          TARGET_BRANCH="$(jq -r '.run_id_writer.branch // "main"' "$CHANNEL_CONFIG")"
          TARGET_FILE="$(jq -r '.run_id_writer.file_path // "input-trigger.txt"' "$CHANNEL_CONFIG")"
          ENABLED="$(jq -r '.run_id_writer.enabled // true' "$CHANNEL_CONFIG")"
          if [[ "$ENABLED" != "true" ]]; then
            echo "run_id_writer disabled in input.json; skipping."
            exit 0
          fi
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          rm -rf _runid_repo
          git clone --depth 1 --branch "$TARGET_BRANCH" "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_REPO}.git" _runid_repo
          cd _runid_repo
          mkdir -p "$(dirname "$TARGET_FILE")" || true
          echo "Run ID: ${RUN_ID}" >> "$TARGET_FILE"
          git add "$TARGET_FILE"
          # Avoid failing when there's nothing new to commit
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git commit -m "Update input-trigger.txt with run ID ${RUN_ID}"
          git push origin "$TARGET_BRANCH"
